En este proyecto desarrollé una API REST sencilla con Node.js y Express, siguiendo la idea de separar el código en modelo, controlador y rutas. El objetivo era poder gestionar tareas con operaciones básicas como listar, crear, eliminar y actualizar, y poco a poco ir resolviendo los problemas que iban apareciendo en el camino.

Lo primero fue definir el modelo. Aquí utilicé un arreglo en memoria para simular la base de datos y cada tarea se genera con un id único usando randomUUID. El modelo expone funciones como findAll para listar todo, addTask para crear, findId para buscar por id, removeTask para borrar y updateTask para cambiar el título. Al inicio findId solo devolvía true o false, y eso hacía que el endpoint no regresara nada; lo corregí para que devuelva la tarea completa o null si no existe. También corregí inconsistencias de nombres entre el modelo y el controlador (tenía addTask en un lado y create en otro), lo que al principio me provocaba errores.

En el controlador fui resolviendo el manejo de las peticiones. Se validó que el título fuera texto, se agregaron los códigos de estado correctos (200, 201, 204, 404, etc.) y mensajes de error cuando una tarea no se encuentra. Aprendí que no basta con “retornar algo”, hay que decidir qué código HTTP usar y qué JSON enviar como respuesta. Una de las confusiones que tuve fue con el body: descubrí que el body de la petición lo construye el cliente (en mi caso Insomnia) y el body de la respuesta lo construye el servidor según lo que yo programe. Eso me ayudó a entender mejor cómo se comunican ambas partes.

En las rutas conecté todo usando express.Router(). Aquí mapeé cada método HTTP con el controlador correspondiente: GET para listar o buscar por id, POST para crear, DELETE para eliminar y PATCH para actualizaciones. Primero hice el patch solo para actualizar el título, pero después añadí la parte de “completar o descompletar” una tarea. Esto lo resolví de dos maneras: con un endpoint que recibe un booleano (PATCH /:id/completed) y con otro que simplemente invierte el estado actual (PATCH /:id/toggle). De esta forma se puede marcar una tarea como hecha, desmarcarla o alternar su estado con una sola llamada.

En resumen, fui construyendo la API paso a paso, corrigiendo errores de lógica, validaciones y consistencia entre las capas del proyecto. El resultado final es una API REST que cumple con las operaciones CRUD básicas y que además permite marcar las tareas como completas o incompletas. Fue un ejercicio útil para entender la arquitectura MVC en Node, el manejo de JSON entre cliente y servidor, y la importancia de los pequeños detalles como validar entradas, nombrar funciones de forma coherente y devolver siempre una respuesta clara.
